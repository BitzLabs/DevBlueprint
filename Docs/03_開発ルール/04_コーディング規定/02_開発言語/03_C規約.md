# 03.C言語 コーディング規約

このドキュメントでは、本プロジェクトでC言語を記述する際の、コーディングスタイルと規約について定めます。
C言語は自由度が高い反面、規約がないとコードの品質に大きな差が生まれるため、一貫したスタイルを保つことが極めて重要です。

!!! note "共通原則との関係"
    本規約は、**[01.共通コーディング原則](../../01_共通規則/01_共通コーディング原則.md)** をC言語に特化・具体化したものです。必ず共通原則にも目を通してください。

---

## 1. 基本方針 (Guiding Principles)

*   本プロジェクトのC言語コードは、**可読性、移植性、安全性**を最優先します。
*   可能な限り、**C99以降**の標準に準拠し、その機能を活用することを推奨します。

---

## 2. 命名規則 (Naming Conventions)

*   **`snake_case` (スネークケース):**
    *   関数名 (`void my_function();`)
    *   変数名 (`int my_variable;`)
*   **`PascalCase` (パスカルケース):**
    *   構造体 (`struct`)、共用体 (`union`)、`enum` の型定義名 (`typedef`)。
    *   例: `typedef struct MyStruct { ... } MyStruct;`
*   **`UPPER_SNAKE_CASE` (大文字のスネークケース):**
    *   マクロ (`#define`) や `enum` のメンバー。
    *   例: `#define MAX_BUFFER_SIZE 1024`, `enum Status { STATUS_OK, STATUS_ERROR };`

---

## 3. レイアウトと書式設定 (Layout and Formatting)

### 3.1. ツールによる自動適用 (Tooling)
手作業でのスタイル遵守は非効率であり、レビューのノイズとなるため、ツールによる規約の遵守を強制します。

*   **フォーマッター: `ClangFormat`**
    *   **役割:** プロジェクトのスタイルを定義した`.clang-format`ファイルに基づき、コードの見た目を自動で統一します。議論の余地なく、一貫したフォーマットを適用します。
    *   **運用:** コミット前に必ずフォーマッターを実行することをルールとします。CI/CDプロセスにフォーマットチェックを組み込むことを強く推奨します。
*   **静的解析: `Clang-Tidy`**
    *   **役割:** Clangベースの静的解析ツールです。コーディングスタイルだけでなく、潜在的なバグ、メモリリークの可能性、未定義動作などをコンパイル前に検出します。
    *   **運用:** CI/CDプロセスに静的解析を組み込み、重大な警告はエラーとして扱うことを強く推奨します。

### 3.2. 主要な書式ルール (Formatting Rules)

以下に示す主要な書式ルールは、`.clang-format` の設定に基づき、フォーマッターによって自動的に適用・チェックされます。

*   **インデント:** 半角スペース4つ。
*   **波括弧 `{}`:**
    *   関数定義、制御構文など、全てのブロックで波括弧は次の行に配置します (Allmanスタイル)。
    *   1行のステートメントでも、常に波括弧を使用します。
*   **1行の長さ:** 120文字以内を目安とします。
*   **`#include`の順序:**
    *   `#include`ディレクティブは、ファイルの先頭にまとめて配置し、以下の順序でグループ化します。この順序は、ヘッダーファイルの自己完結性を保証するのに役立ちます。
    1.  対応するヘッダーファイル自身（例: `my_module.c`なら`"my_module.h"`）
    2.  C標準ライブラリ (`<stdio.h>`, `<stdlib.h>`など)
    3.  外部ライブラリのヘッダー
    4.  プロジェクト内の他のヘッダー
*   **空行:**
    *   関数定義の間や、論理的なコードブロックの間に適切に空行を挿入し、可読性を高めます。
*   **スペース:**
    *   演算子、カンマの前後などに適切にスペースを挿入します。

---

## 4. コメント (Comments)

*   **ドキュメントコメント (`/** ... */`) の役割:**
    *   本プロジェクトでは、**02.設計仕様/01.API仕様** を仕様の正とし、ソースコードのドキュメントコメントは補助的な役割と位置づけます。
    *   公開APIの仕様や説明は、ソースコード内ではなく、設計仕様書に記述します。
    *   `Doxygen` 形式のコメントは、あくまでコードからAPIリファレンスを生成するための補助ツールとして利用します。詳細な仕様を記述する必要はありません。

*   **通常のコメント (`//` または `/* ... */`)**:
    *   コードが「何をしているか」よりも「**なぜそうしているのか**」という設計意図や背景を説明するために使用します。
    *   複雑なアルゴリズムや、一見して意図が分かりにくいコードには、簡潔なコメントを付与してください。
    *   コメントは、コードの変更に合わせて常に最新の状態に保ちます。

*   **要求IDとの連携**:
    *   **01.共通コーディング原則** で定められた通り、機能の実装に対応する要求IDを、関数の直前のコメントとして明記します。
    ```c
    // REQ-AUTH-1.1: ユーザー名とパスワードで認証を行う
    int authenticate_user(const char* username, const char* password)
    {
        // なぜこの処理が必要か、という意図を記述...
        // ...
    }
    ```
---

## 5. 言語機能の利用方針 (Language Features)

### 5.1. C99/C11標準の活用 (Standard Features)
*   **固定幅整数型:** `int` や `long` の代わりに、`<stdint.h>` で定義される `int32_t`, `uint64_t` などを積極的に利用し、ビット幅を明確にします。
*   **`bool`型:** `<stdbool.h>` をインクルードし、`_Bool` の代わりに `bool`, `true`, `false` を使用します。
*   **`for`ループ内での変数宣言:** `for (int i = 0; ...)` のように、ループ変数のスコープを最小限に留めます。

### 5.2. ヘッダーファイル (Header Files)
*   **インクルードガード:** 全てのヘッダーファイルには、多重インクルードを防止するためのインクルードガードを**必ず**記述します。
    ```c
    #ifndef MY_MODULE_H
    #define MY_MODULE_H

    // ... content ...

    #endif /* MY_MODULE_H */
    ```
    
    `#endif`の後ろにガード名をコメントとして記述すると、ネストが深くなった際に分かりやすくなります。
*   **`#pragma once` の利用:** `#pragma once` は多くのモダンなコンパイラでサポートされており、インクルードガードよりも簡潔です。プロジェクトで利用するコンパイラが全て対応している場合は、こちらを優先的に使用することを推奨します。

### 5.3. プリプロセッサとマクロ (Preprocessor and Macros)
*   **関数形式マクロの注意点:**
    *   マクロは型チェックを行わないため、可能な限り `static inline` 関数で代替することを検討してください。
    *   マクロを使用する場合は、引数を必ず括弧 `()` で囲み、意図しない演算子の優先順位の問題を避けてください。
        ```c
        // 悪い例
        #define SQUARE(x) x * x
        // SQUARE(a + b) は a + b * a + b と展開されてしまう

        // 良い例
        #define SQUARE(x) ((x) * (x))
        ```
    *   複数行にわたるマクロは `do { ... } while (0)` で囲み、`if`文などの制御構文内で安全に使用できるようにします。
*   **`#if` vs `#ifdef`:**
    *   単なる定義の有無（On/Off）で切り替える場合は `#ifdef` を使用します。
    *   特定の値（`0`, `1`など）で条件分岐する場合は `#if` を使用します。

---

## 6. エラー処理 (Error Handling)

C言語には例外機構がないため、エラーの発生を呼び出し元に確実に伝え、適切に処理するための統一された規約が極めて重要です。

### 6.1. 戻り値によるエラー通知 (Return Values)

*   **成功/失敗の通知:**
    *   関数の処理が成功したか失敗したかを示す場合は、`int`型または`bool`型（`<stdbool.h>`）を戻り値とすることを標準とします。
    *   **成功時に `0` または `true`** を、**失敗時に負の値または `false`** を返すように統一します。
*   **エラー詳細の伝達:**
    *   エラーの詳細な理由（エラーコードなど）を伝える必要がある場合は、関数の引数として出力用のポインタを渡すパターンを推奨します。
    ```c
    // 戻り値で成否を、出力引数で結果やエラーコードを返す
    bool get_user_data(int user_id, UserData* out_data, ErrorCode* out_error);
    ```

### 6.2. `errno` の利用 (Using errno)

*   `<stdio.h>`や`<math.h>`などの標準ライブラリ関数は、失敗時にグローバル変数 `errno` にエラーコードを設定します。
*   **利用時の注意点:**
    *   `errno` をチェックする前には、必ず `errno = 0;` のようにリセットしてください。`errno` は成功時にクリアされないため、過去のエラー値を誤って検出する可能性があります。
    *   `strerror(errno)` を使用することで、エラーコードに対応する説明文字列を取得できます。

### 6.3. カスタムエラーコード (Custom Error Codes)

*   プロジェクト固有のエラー状態を管理するために、`enum` を使ったカスタムエラーコード体系を定義することを強く推奨します。
*   これにより、エラーの種類を型安全かつ網羅的に扱うことができます。

### 6.4. 致命的なエラーの扱い (Handling Fatal Errors)

*   プログラムの前提条件が破壊されるような、回復不可能なエラー（例: `NULL`ポインタが渡されるべきでない関数に渡された）を検出するため、**`assert`マクロ (`<assert.h>`)** を積極的に利用します。
*   `assert`は、デバッグビルド時（`NDEBUG`が未定義の場合）にのみ有効となり、リリースビルドでは無効化されるため、パフォーマンスへの影響はありません。

### 6.5. goto文によるクリーンアップ

*   複数のリソース（メモリ、ファイルディスクリプタ等）を確保する関数において、エラー発生時の解放処理を１箇所にまとめる目的でのみ、`goto`文の使用を許可します。
*   これはLinuxカーネルなどでも見られる、C言語における一般的なエラー処理パターンです。
    ```c
    int process_data(void) {
        void* resource1 = malloc(100);
        if (!resource1) {
            return -1;
        }

        FILE* resource2 = fopen("data.txt", "r");
        if (!resource2) {
            goto fail_resource1;
        }

        // ... 正常処理 ...

        fclose(resource2);
        free(resource1);
        return 0;

    fail_resource1:
        free(resource1);
        return -1;
    }
    ```

---

## 7. 安全なコーディングプラクティス (Safe Coding Practices)

C言語は強力である一方、メモリ管理や未定義動作など、危険な落とし穴が多く存在します。安全なコードを書くためのプラクティスを徹底してください。

### 7.1. コンパイラ警告 (Compiler Warnings)
*   コンパイラの警告レベルは、可能な限り高く設定します。
    *   **GCC/Clang:** `-Wall -Wextra -Werror`
    *   **MSVC (Visual Studio):** `/W4` または `/Wall`
*   **全ての警告はエラーとして扱い、修正することを原則とします。** 警告を無視してはいけません。

### 7.2. ポインターとメモリ管理 (Pointers and Memory Management)
*   ポインター変数は、宣言と同時に初期化します（`NULL`または有効なアドレスで）。初期化されていないポインターは非常に危険です。
*   `malloc` などで動的に確保したメモリは、不要になったら**必ず** `free` で解放します。誰がメモリの所有権を持つのかを常に意識して設計してください。

### 7.3. バッファオーバーフロー対策 (Buffer Overflow Protection)
*   `strcpy` や `strcat` のような、バッファサイズを考慮しない危険な関数は使用を**禁止**します。
*   代わりに、`snprintf` や `strncpy` などの、書き込むサイズを制限できる安全な関数を使用してください。

### 7.4. `const`の積極的な利用 (Use of const)
*   変更されるべきでない変数やポインター引数には、積極的に`const`修飾子を付け、意図しない変更をコンパイラに検出させます。
*   例: `void print_string(const char* str);`

### 7.5. 未定義動作の回避 (Avoiding Undefined Behavior)
*   C言語の仕様で動作が保証されていない「未定義動作」に依存したコードは、コンパイラや環境によって予期せぬ挙動を引き起こすため、**絶対に避けてください。**
*   **具体例:**
    *   **符号付き整数のオーバーフロー:** `int max = INT_MAX; int result = max + 1;` のようなコードは未定義動作です。
    *   **NULLポインタのデリファレンス:** `int* p = NULL; *p = 10;`
    *   **解放済みメモリへのアクセス:** `free(p); *p = 10;`

---

## 8. パフォーマンスに関する考慮事項 (Performance Considerations)

!!! warning "早すぎる最適化は諸悪の根源"
    パフォーマンスの最適化は、プロファイリングによってボトルネックが特定された後に行うべきです。
    明確な根拠なく、可読性を犠牲にするような最適化は避けてください。

### 8.1. キーワードの活用

*   **`inline` キーワード:**
    *   頻繁に呼び出される小さな関数に対して `inline` を付与することで、コンパイラに関数呼び出しのオーバーヘッドを削減するためのインライン展開を推奨できます。
    *   ただし、最終的にインライン化するかどうかはコンパイラの判断に委ねられます。
*   **`restrict` キーワード (C99):**
    *   ポインタ引数に対して `restrict` を付与することで、そのポインタが指すメモリ領域が、他のポインタからはアクセスされないことをコンパイラに伝えます。
    *   これにより、コンパイラはより積極的な最適化（例: 命令の並べ替え）を行うことができます。

### 8.2. データアライメントとパディング

*   CPUは、特定のデータ型（例: `int`, `double`）を、そのサイズの倍数となるメモリアドレスから読み込む方が高速です。
*   構造体のメンバの順序によっては、コンパイラがアライメントを維持するために、メンバ間に余分なパディング（隙間）を挿入することがあります。
*   パフォーマンスが重要な場面では、サイズの大きいメンバから順に定義することで、パディングを最小限に抑え、キャッシュ効率を高めることを意識してください。

---

## 9. 移植性と環境依存 (Portability and Environment Dependencies)

C言語のコードは、異なるアーキテクチャやOSでコンパイル・実行される可能性があります。特定の環境に依存したコードは、移植性を著しく低下させるため、以下の点に注意してください。

### 9.1. データ型とサイズ (Data Types and Sizes)

*   `int`や`long`といった基本データ型のサイズは、処理系（コンパイラやCPUアーキテクチャ）によって異なります。（例: 64bit環境では`long`が64bitだが、32bit環境では32bit）
*   サイズの互換性が重要な場面（バイナリファイルのI/O、ネットワーク通信、ハードウェアレジスタ操作など）では、必ず **`<stdint.h>`** で定義される **`int32_t`** や **`uint64_t`** のような固定幅整数型を使用してください。

### 9.2. エンディアン (Endianness)

*   マルチバイトのデータをメモリに格納する順序（バイトオーダー）には、ビッグエンディアンとリトルエンディアンの2種類があります。
*   ネットワーク通信（常にビッグエンディアン）や、異なるシステム間で共有されるバイナリファイルを扱う際は、エンディアンの違いを吸収する必要があります。
*   `htons()` (host to network short) や `ntohl()` (network to host long) といった標準的な関数を利用して、適切にバイトオーダーを変換してください。

### 9.3. 処理系定義の動作 (Implementation-Defined Behavior)

*   C言語の規格では、一部の動作が「処理系定義（implementation-defined）」とされています。これは、コンパイラによって挙動が異なる可能性があることを意味します。
*   **`char`型が符号付き (`signed`) か符号なしか (`unsigned`)** は、その代表例です。文字コードの範囲外の値を`char`に格納すると、意図しない挙動を引き起こす可能性があります。文字データ以外を扱う場合は、`signed char`または`unsigned char`を明示的に使用してください。

---

## 10. その他 (Miscellaneous)

*   **不変性 (Immutability):**
    *   変更されるべきでない変数やデータ構造に対しては、`const`を積極的に利用し、不変性を高めることを意識してください。これにより、意図しない副作用を防ぎ、コードの安全性が向上します。

*   **コメントアウトされたコードの禁止 (No Commented-out Code):**
    *   不要になったコードは、コメントアウトして残さずに削除してください。コードの履歴はGitのバージョン管理システムで追跡します。リポジトリをクリーンに保ち、後からコードを読む人の混乱を避けます。