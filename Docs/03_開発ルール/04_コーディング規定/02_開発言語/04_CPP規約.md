# 04.C++ コーディング規約

このドキュメントでは、本プロジェクトでC++を記述する際の、コーディングスタイルと規約について定めます。
モダンC++ (C++17以降) の機能を最大限に活用し、**安全性、保守性、パフォーマンス**の高いコードを目指します。

!!! note "共通原則およびC言語規約との関係"
    - 本規約は、**[01.共通コーディング原則](../01_共通規則/01_共通コーディング原則.md)** をC++言語に特化・具体化したものです。
    - C言語と共通する部分（命名規則、ヘッダーファイルのインクルードガードなど）については、**[C言語コーディング規約](./03_C規約.md)** も参考にしてください。

---

## 1. 基本方針 (Guiding Principles)

*   本プロジェクトのC++コードは、Bjarne Stroustrupらが主導する**[C++ Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)**の思想に準拠することを目指します。
*   可能な限り、**C++17以降**の標準に準拠し、その機能を活用することを推奨します。

---

## 2. 命名規則 (Naming Conventions)

*   **`snake_case` (スネークケース):**
    *   関数名、メソッド名、変数名。
*   **`PascalCase` (パスカルケース):**
    *   クラス名、構造体名、`enum class` 名。
*   **`UPPER_SNAKE_CASE` (大文字のスネークケース):**
    *   マクロ、`enum class` のメンバー。
*   **メンバ変数 (Member Variables):**
    *   `snake_case_` のように、末尾にアンダースコアを付けます。

---

## 3. レイアウトと書式設定 (Layout and Formatting)

### 3.1. ツールによる自動適用 (Tooling)
手作業でのスタイル遵守は非効率であり、レビューのノイズとなるため、ツールによる規約の遵守を強制します。

*   **フォーマッター: `ClangFormat`**
    *   `.clang-format`ファイルでプロジェクトのスタイルを定義し、コードの見た目を統一します。
*   **静的解析: `Clang-Tidy`**
    *   潜在的なバグ、リソースリーク、ガイドライン違反などを自動で検出します。CI/CDへの統合を強く推奨します。

### 3.2. 主要な書式ルール (Formatting Rules)
以下に示す主要な書式ルールは、`.clang-format` の設定に基づき、フォーマッターによって自動的に適用・チェックされます。

*   **インデント:** 半角スペース4つ。
*   **波括弧 `{}`:**
    *   クラス定義、関数定義、制御構文など、全てのブロックで波括弧は次の行に配置します (Allmanスタイル)。
    *   1行のステートメントでも、常に波括弧を使用します。
*   **1行の長さ:** 120文字以内を目安とします。
*   **`#include`の順序:**
    *   `#include`ディレクティブは、ファイルの先頭にまとめて配置し、以下の順序でグループ化します。この順序は、ヘッダーファイルの自己完結性を保証するのに役立ちます。
    1.  対応するヘッダーファイル自身（例: `user_service.cpp`なら`"user_service.h"`）
    2.  C++標準ライブラリ (`<vector>`, `<string>`など)
    3.  外部ライブラリのヘッダー
    4.  プロジェクト内の他のヘッダー
*   **空行:**
    *   関数定義の間や、論理的なコードブロックの間に適切に空行を挿入し、可読性を高めます。
*   **スペース:**
    *   演算子、カンマの前後などに適切にスペースを挿入します。
*   **`this->` の使用:**
    *   メンバ変数とローカル変数の名前が衝突する場合など、曖昧さを避ける必要がある場合を除き、原則として `this->` は省略します。

---

## 4. コメント (Comments)

*   コードが**「何をしているか(What)」**を説明するコメントは、コード自体が明確であれば不要です。
*   コメントは、そのコードの**「なぜそうなっているのか(Why)」**という、コードだけでは表現しきれない設計意図、背景、トレードオフを説明するために使用します。
*   **要求IDとの連携**:
    *   **01.共通コーディング原則** で定められた通り、機能の実装に対応する要求IDを、クラスやメソッドのコメントとして明記します。
*   **ファイルヘッダーコメント (推奨):**
    *   各ソースファイル（`.cpp`, `.h`）の先頭には、そのファイルの内容を要約するヘッダーコメントを記述することを推奨します。

---

## 5. 言語機能の利用方針 (Language Features)

### 5.1. リソース管理: RAIIとスマートポインタ
*   **RAII (Resource Acquisition Is Initialization) の徹底:**
    *   リソース（メモリ、ファイル、ソケット等）は、その生存期間を管理するオブジェクト（クラス）のコンストラクタで取得し、デストラクタで解放するRAIIパターンを徹底します。
*   **手動の`new`/`delete`は原則禁止:**
    *   メモリ管理には、以下のスマートポインタを必ず使用してください。
    *   **`std::unique_ptr`**: リソースの唯一の所有権を示す場合の第一選択。
    *   **`std::shared_ptr`**: 複数のポインタがリソースの所有権を共有する場合。
    *   **`std::make_unique` / `std::make_shared`**: スマートポインタを作成する際は、これらのヘルパー関数を使用します。

### 5.2. 推奨される言語機能
*   **`auto`キーワード:** 型が右辺から自明な場合や、イテレーターなどの複雑な型を扱う場合は、`auto`を積極的に利用し、コードの冗長性を減らします。
*   **範囲ベースforループ:** コンテナの全要素を走査する場合は、インデックスベースの古い`for`ループではなく、範囲ベースforループを使用します。
*   **`nullptr`の使用:** ヌルポインターを示す場合は、C言語由来の`NULL`マクロではなく、型安全な`nullptr`を必ず使用します。
*   **`const`と`constexpr`:** 変更しない変数には`const`を、コンパイル時定数には`constexpr`を積極的に利用し、不変性（Immutability）を高めます。
*   **`enum class`の使用:** 型安全でない古い`enum`ではなく、スコープを持ち、暗黙的な整数変換のない`enum class`を使用します。
*   **構造化束縛 (C++17):** `std::pair` や `std::tuple` から複数の値を取り出す際は、構造化束縛を利用してコードを簡潔にします。

### 5.3. クラス設計
*   **`override`と`final`:** 仮想関数をオーバーライドする際は`override`キーワードを、これ以上派生させないクラスや仮想関数には`final`キーワードを明記します。
*   **`default`と`delete`:** コンパイラが自動生成する特殊なメンバー関数を明示的にデフォルト実装させたい場合は`= default;`を、禁止したい場合は`= delete;`を使用します。

### 5.4. ヘッダーファイル (Header Files)
*   インクルードガードや`#pragma once`の利用については、C言語規約と同様のルールを適用します。

---
### 5.5. 名前空間 (Namespaces)

*   `using namespace` ディレクティブは、ヘッダーファイル (`.h`, `.hpp`) 内での使用を**禁止**します。
*   ソースファイル (`.cpp`) 内での使用も、関数スコープなどの限定的な範囲に留め、グローバルスコープでの使用は避けてください。
*   **理由:** ヘッダーファイルで `using namespace` を使用すると、そのヘッダーをインクルードした全てのファイルで名前空間が汚染され、意図しない名前の衝突を引き起こす可能性があります。
*   代わりに、`std::vector` や `std::string` のように、常にプレフィックスを付けて使用してください。

---

## 6. エラー処理と例外 (Error Handling and Exceptions)

*   エラーは、例外を用いて明確に通知します。戻り値でのエラーコードは、パフォーマンスが極めて重要な場合や、C言語ライブラリとの連携など、限定的な場面でのみ使用します。
*   標準ライブラリの例外クラス (`std::runtime_error`, `std::invalid_argument`など) を適切に使い分けます。
*   例外を送出しないことが保証される関数には、**`noexcept`** を明記し、コンパイラの最適化を助けます。

---

## 7. 安全なコーディングプラクティス (Safe Coding Practices)

### 7.1. コンパイラ警告 (Compiler Warnings)
*   コンパイラの警告レベルは、可能な限り高く設定します。
    *   **GCC/Clang:** `-Wall -Wextra -Werror`
    *   **MSVC (Visual Studio):** `/W4` または `/Wall`
*   **全ての警告はエラーとして扱い、修正することを原則とします。**

### 7.2. `const`の積極的な利用 (Use of const)
*   変更されるべきでない変数や引数に加え、**メンバ変数を変更しないメンバ関数**にも`const`を付け、意図しない状態変更を防ぎます。
    ```cpp
    class User {
    public:
        std::string get_name() const; // このメソッドはメンバ変数を変更しない
    private:
        std::string name_; // 末尾に"_"を付ける
    };
    ```

### 7.3. 未定義動作の回避 (Avoiding Undefined Behavior)
*   C言語規約と同様に、符号付き整数のオーバーフローや解放済みメモリへのアクセスなど、未定義動作に依存したコードは絶対に避けてください。

---

## 8. パフォーマンスに関する考慮事項 (Performance Considerations)

!!! warning "早すぎる最適化は諸悪の根源"
    パフォーマンスの最適化は、プロファイリングによってボトルネックが特定された後に行うべきです。
    明確な根拠なく、可読性を犠牲にするような最適化は避けてください。

### 8.1. ムーブセマンティクス (Move Semantics)
*   リソースの所有権を移動させる際は、高コストなコピーを避け、`std::move`を適切に利用してムーブセマンティクスを活用します。

### 8.2. インライン展開 (Inlining)
*   頻繁に呼び出される小さな関数は、ヘッダーファイル内で`inline`キーワードを付けて定義することで、インライン展開を促し、関数呼び出しのオーバーヘッドを削減できます。

---

## 9. 移植性と環境依存 (Portability and Environment Dependencies)

C言語規約と同様のルールを適用します。

*   **データ型とサイズ:** サイズの互換性が重要な場面では、`<cstdint>`の`int32_t`などを利用します。
*   **エンディアン:** ネットワーク通信などではバイトオーダーを意識し、適切に変換します。

---

## 10. 非同期処理 (Asynchronous Processing)

*   `std::async`, `std::future`, `std::thread` などの標準ライブラリ機能を活用し、ブロッキングな処理を避けます。
*   C++20以降が利用可能な場合は、コルーチンの利用も検討します。

---

## 11. その他 (Miscellaneous)

*   **不変性 (Immutability):**
    *   変更されるべきでない変数やデータ構造に対しては、`const`や`constexpr`を積極的に利用し、不変性を高めることを意識してください。

*   **コメントアウトされたコードの禁止 (No Commented-out Code):**
    *   不要になったコードは、コメントアウトして残さずに削除してください。コードの履歴はGitのバージョン管理システムで追跡します。
